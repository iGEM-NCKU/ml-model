<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Biofilm Prediction Tool v8.1</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Nunito:wght@700;800&family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: 'Inter', sans-serif;
        background-color: #f8f7f2;
        color: #1a472a;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        font-family: 'Nunito', sans-serif;
      }
      .card {
        background-color: #ffffff;
        @apply rounded-xl shadow-lg ring-1 ring-black/5;
      }
      .status-dot {
        @apply w-2.5 h-2.5 rounded-full transition-colors;
      }
      .tooltip {
        @apply absolute invisible z-20 w-max max-w-xs bg-gray-800 text-white text-xs rounded-lg px-3 py-2 -mt-10 transition-opacity duration-300 shadow-xl;
      }
      .has-tooltip:hover .tooltip {
        @apply visible opacity-100;
      }
      input[type='number']::-webkit-inner-spin-button,
      input[type='number']::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      input[type='number'] {
        -moz-appearance: textfield;
      }
      .custom-scrollbar::-webkit-scrollbar {
        height: 8px;
      }
      .custom-scrollbar::-webkit-scrollbar-track {
        background-color: #f1f5f9;
        border-radius: 10px;
      }
      .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: #a8c899;
        border-radius: 10px;
      }
      .sticky-header thead {
        position: sticky;
        top: 0;
        z-index: 10;
      }
    </style>
  </head>
  <body class="text-gray-800">
    <div class="container mx-auto p-4 sm:p-6 lg:p-8 max-w-7xl">
      <header class="flex justify-between items-center mb-10">
        <div class="flex items-center space-x-4">
          <img src="./byefilm.png" alt="Logo" class="w-200 h-12" />
          <div>
            <h1 class="text-3xl font-extrabold text-[#1A472A]">
              Biofilm Prediction Tool
            </h1>
            <p class="text-gray-500 text-sm">
              Optimize and predict biofilm removal using enzyme mixtures.
            </p>
          </div>
        </div>
        <div class="flex items-center space-x-3">
          <div
            id="status-dot"
            class="status-dot bg-yellow-400 animate-pulse"
          ></div>
          <span id="status-text" class="text-sm text-yellow-600 font-medium"
            >Connecting to API...</span
          >
        </div>
      </header>

      <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
        <div class="lg:col-span-1 flex flex-col gap-8">
          <div class="card p-6">
            <h2 class="text-xl font-bold mb-4">Standard Assay Conditions</h2>
            <div class="space-y-4">
              <div class="grid grid-cols-2 gap-4">
                <div>
                  <label
                    for="fixed-ph"
                    class="block text-sm font-medium text-gray-700"
                    >pH</label
                  ><input
                    type="number"
                    id="fixed-ph"
                    value="7.4"
                    step="0.1"
                    class="mt-1 w-full bg-gray-100 border-gray-300 rounded-lg shadow-sm p-2 text-sm"
                  />
                </div>
                <div>
                  <label
                    for="fixed-temp"
                    class="block text-sm font-medium text-gray-700"
                    >Temp (°C)</label
                  ><input
                    type="number"
                    id="fixed-temp"
                    value="37"
                    class="mt-1 w-full bg-gray-100 border-gray-300 rounded-lg shadow-sm p-2 text-sm"
                  />
                </div>
              </div>
              <div class="grid grid-cols-2 gap-4">
                <div>
                  <label
                    for="total-volume"
                    class="block text-sm font-medium text-gray-700"
                    >Total Volume (µL)</label
                  ><input
                    type="number"
                    id="total-volume"
                    value="100"
                    class="mt-1 w-full bg-gray-100 border-gray-300 rounded-lg shadow-sm p-2 text-sm"
                  />
                </div>
                <div>
                  <label
                    for="biofilm-age"
                    class="block text-sm font-medium text-gray-700"
                    >Biofilm Age (h)</label
                  ><input
                    type="number"
                    id="biofilm-age"
                    value="24"
                    class="mt-1 w-full bg-gray-100 border-gray-300 rounded-lg shadow-sm p-2 text-sm"
                  />
                </div>
              </div>
              <div>
                <label
                  for="control-od"
                  class="block text-sm font-medium text-gray-700"
                  >Control OD600</label
                ><input
                  type="number"
                  id="control-od"
                  step="0.01"
                  value="0.80"
                  class="mt-1 w-full bg-gray-100 border-gray-300 rounded-lg shadow-sm p-2 text-sm"
                />
              </div>
            </div>
            <div class="mt-6 border-t pt-4">
              <button
                id="find-optimal-mix-btn"
                class="w-full px-5 py-2.5 rounded-lg font-semibold text-sm bg-[#A8C899] text-[#1A472A] hover:bg-[#99bb8a] shadow-md transition-colors shadow-md"
              >
                Find Optimal Mix
              </button>
            </div>
          </div>
          <div class="card p-6">
            <h2 class="text-xl font-bold mb-4">Results Summary</h2>
            <div id="summary-metrics" class="space-y-3 text-sm">
              <div class="flex justify-between items-center">
                <span class="text-gray-600">Experiments Run:</span
                ><span id="summary-count" class="font-bold text-lg">0</span>
              </div>
              <div class="flex justify-between items-center">
                <span class="text-gray-600">Best Prediction:</span
                ><span
                  id="summary-best"
                  class="font-bold text-lg text-green-600"
                  >-</span
                >
              </div>
              <div class="flex justify-between items-center">
                <span class="text-gray-600">Mean Prediction:</span
                ><span id="summary-mean" class="font-bold text-lg">-</span>
              </div>
            </div>
          </div>
          <div class="card p-6">
            <h2 class="text-xl font-bold mb-4">Prediction Analysis</h2>
            <div id="analysis-metrics" class="space-y-3 text-sm">
              <div class="flex justify-between items-center">
                <span class="text-gray-600">Model Accuracy (MAE):</span
                ><span id="analysis-mae" class="font-bold text-lg">-</span>
              </div>
              <p class="text-xs text-gray-500 italic mt-2">
                Mean Absolute Error between actual and predicted values.
              </p>
            </div>
          </div>
        </div>

        <div class="lg:col-span-2">
          <div class="card overflow-hidden">
            <div class="overflow-x-auto custom-scrollbar sticky-header">
              <table class="w-full" id="experiment-table">
                <thead class="bg-gray-50">
                  <tr class="text-left text-sm font-semibold text-gray-600">
                    <th class="p-4">#</th>
                    <th class="p-4 min-w-[320px]">Volume Ratios</th>
                    <th class="p-4">Strategy</th>
                    <th class="p-4">Delays (h)</th>
                    <th class="p-4">Time (h)</th>
                    <th class="p-4">Final OD</th>
                    <th class="p-4">Actual</th>
                    <th class="p-4 min-w-[250px]">Predicted</th>
                    <th class="p-4">Action</th>
                  </tr>
                </thead>
                <tbody id="table-body" class="divide-y divide-gray-100"></tbody>
              </table>
            </div>
          </div>
          <div class="mt-6 flex justify-center gap-4">
            <button
              id="add-row-btn"
              class="px-5 py-2.5 rounded-lg font-semibold text-sm bg-[#A8C899] text-[#1A472A] hover:bg-[#99bb8a] shadow-md"
            >
              Add Experiment
            </button>
            <button
              id="import-csv-btn"
              class="px-5 py-2.5 rounded-lg font-semibold text-sm bg-gray-200 text-gray-500 cursor-not-allowed shadow-md"
            >
              Import CSV (Future)
            </button>
            <button
              id="export-csv-btn"
              class="px-5 py-2.5 rounded-lg font-semibold text-sm bg-white text-gray-700 border border-gray-300 hover:bg-gray-100 shadow-md"
            >
              Export CSV
            </button>
          </div>
        </div>
      </div>

      <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mt-8">
        <div class="card p-6 lg:col-span-2">
          <h2 class="text-xl font-bold mb-4">Predicted vs. Actual Removal</h2>
          <div id="plot-actual-vs-predicted" class="min-h-[400px]"></div>
        </div>
        <div class="card p-6">
          <h2 class="text-xl font-bold mb-4">Top 10 Feature Importances</h2>
          <div id="plot-feature-importance" class="min-h-[400px]"></div>
        </div>
        <div class="card p-6">
          <h2 class="text-xl font-bold mb-4">
            Enzyme Ratio vs. Predicted Removal
          </h2>
          <div id="ternary-plot" class="min-h-[400px]"></div>
        </div>
      </div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const API_URL = 'http://127.0.0.1:8000';
        const tableBody = document.getElementById('table-body');
        const addRowBtn = document.getElementById('add-row-btn');
        const findOptimalMixBtn = document.getElementById(
          'find-optimal-mix-btn'
        );
        const exportCsvBtn = document.getElementById('export-csv-btn');
        let experimentCount = 0;
        const inputBaseClasses =
          'w-full bg-gray-100 border-gray-300 rounded-lg shadow-sm p-2 text-sm';

        async function checkApiStatus() {
          const statusDot = document.getElementById('status-dot');
          const statusText = document.getElementById('status-text');
          try {
            const response = await fetch(`${API_URL}/`);
            if (!response.ok) throw new Error('API not ready');
            const data = await response.json();
            statusDot.className = 'status-dot bg-green-500';
            statusText.textContent = `API Connected (${data.model})`;
            statusText.className = 'text-sm text-green-700 font-medium';
            renderFeatureImportancePlot();
          } catch (error) {
            statusDot.className = 'status-dot bg-red-500 animate-pulse';
            statusText.textContent = 'API Offline';
            statusText.className = 'text-sm text-red-600 font-medium';
          }
        }

        const initialData = [
          {
            dspb: 1,
            dnase: 3,
            prok: 2,
            strategy: 0,
            totalTime: 24,
            dnaseTime: 0,
            prokTime: 4,
          },
          {
            dspb: 1,
            dnase: 3,
            prok: 2,
            strategy: 1,
            totalTime: 24,
            dnaseTime: 2,
            prokTime: 6,
          },
        ];

        function createRow(config) {
          experimentCount++;
          const row = document.createElement('tr');
          row.className = 'hover:bg-gray-50';
          row.dataset.id = experimentCount;
          row.innerHTML = `
            <td class="p-4 text-gray-500 font-medium">${String(
              experimentCount
            ).padStart(2, '0')}</td>
            <td class="p-4"><div class="space-y-2">
                <div class="flex items-center gap-2"><label class="text-xs font-bold text-gray-500 w-24">Dispersin B</label><input type="number" class="ratio-dspb ${inputBaseClasses}" value="${config.dspb.toFixed(
            2
          )}" min="0"></div>
                <div class="flex items-center gap-2"><label class="text-xs font-bold text-gray-500 w-24">DNase I</label><input type="number" class="ratio-dnase ${inputBaseClasses}" value="${config.dnase.toFixed(
            2
          )}" min="0"></div>
                <div class="flex items-center gap-2"><label class="text-xs font-bold text-gray-500 w-24">Proteinase K</label><input type="number" class="ratio-prok ${inputBaseClasses}" value="${config.prok.toFixed(
            2
          )}" min="0"></div>
            </div></td>
            <td class="p-4"><select class="strategy-select ${inputBaseClasses} w-48"><option value="0" ${
            config.strategy == 0 ? 'selected' : ''
          }>DspB+DNase First</option><option value="1" ${
            config.strategy == 1 ? 'selected' : ''
          }>Fully Sequential</option></select></td>
            <td class="p-4"><div class="space-y-2"><input type="number" title="DNase Add Time" class="dnase-time ${inputBaseClasses} w-24" value="${
            config.dnaseTime
          }" min="0"><input type="number" title="ProK Add Time" class="prok-time ${inputBaseClasses} w-24" value="${
            config.prokTime
          }" min="0"></div></td>
            <td class="p-4"><input type="number" class="total-time ${inputBaseClasses} w-24" value="${
            config.totalTime
          }" min="1"></td>
            <td class="p-4"><input type="number" class="od600 ${inputBaseClasses} w-24" step="0.01" min="0"></td>
            <td class="p-4 font-semibold removal-actual">-</td>
            <td class="p-4 font-medium removal-predicted">-</td>
            <td class="p-4"><button class="get-prediction-btn px-4 py-2 rounded-lg font-semibold text-xs bg-[#A8C899] text-[#1A472A] hover:bg-[#99bb8a]">Predict</button></td>
          `;
          tableBody.appendChild(row);
          attachRowListeners(row);
          updateRowState(row);
        }

        function attachRowListeners(row) {
          row
            .querySelector('.od600')
            .addEventListener('input', () => calculateRemoval(row));
          row
            .querySelector('.get-prediction-btn')
            .addEventListener('click', (e) =>
              getPrediction(row, e.currentTarget)
            );
          row
            .querySelector('.strategy-select')
            .addEventListener('change', () => updateRowState(row));
        }

        function updateRowState(row) {
          const strategy = row.querySelector('.strategy-select').value;
          const dnaseTimeInput = row.querySelector('.dnase-time');
          if (strategy === '0') {
            dnaseTimeInput.value = 0;
            dnaseTimeInput.disabled = true;
          } else {
            dnaseTimeInput.disabled = false;
          }
        }

        function calculateRemoval(row) {
          const controlOD = parseFloat(
            document.getElementById('control-od').value
          );
          const finalOD = parseFloat(row.querySelector('.od600').value);
          const removalCell = row.querySelector('.removal-actual');
          if (!isNaN(controlOD) && !isNaN(finalOD) && controlOD > 0) {
            const removal = Math.max(
              0,
              ((controlOD - finalOD) / controlOD) * 100
            );
            removalCell.textContent = `${removal.toFixed(1)}%`;
            removalCell.dataset.actual = removal;
          } else {
            removalCell.textContent = '-';
            delete removalCell.dataset.actual;
          }
          updateAllVisualizations();
        }

        async function getPrediction(row, button) {
          button.disabled = true;
          button.textContent = '...';
          const predictionCell = row.querySelector('.removal-predicted');
          predictionCell.innerHTML =
            '<span class="animate-pulse text-gray-400">Calculating...</span>';
          const payload = {
            DspB_ratio: parseFloat(row.querySelector('.ratio-dspb').value),
            DNase_I_ratio: parseFloat(row.querySelector('.ratio-dnase').value),
            ProK_ratio: parseFloat(row.querySelector('.ratio-prok').value),
            Addition_Strategy: parseInt(
              row.querySelector('.strategy-select').value
            ),
            pH: parseFloat(document.getElementById('fixed-ph').value),
            Temperature: parseFloat(
              document.getElementById('fixed-temp').value
            ),
            Total_Volume: parseFloat(
              document.getElementById('total-volume').value
            ),
            biofilm_age_hours: parseFloat(
              document.getElementById('biofilm-age').value
            ),
            Reaction_Time: parseFloat(row.querySelector('.total-time').value),
            DNase_Addition_Time: parseFloat(
              row.querySelector('.dnase-time').value
            ),
            ProK_Addition_Time: parseFloat(
              row.querySelector('.prok-time').value
            ),
          };
          try {
            const response = await fetch(`${API_URL}/predict`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });
            const result = await response.json();
            if (!response.ok) {
              throw new Error(
                (result.detail && result.detail[0]?.msg) ||
                  result.detail ||
                  'Prediction failed.'
              );
            }
            predictionCell.innerHTML = `
              <div class="flex items-center gap-3">
                  <span class="font-bold text-lg text-gray-800" data-prediction="${
                    result.mean_prediction
                  }">${result.mean_prediction.toFixed(1)}%</span>
                  <div class="w-full bg-gray-200 rounded-full h-2.5"><div class="bg-green-600 h-2.5 rounded-full" style="width: ${
                    result.mean_prediction
                  }%"></div></div>
              </div>
              <div class="text-xs text-gray-500 mt-1 has-tooltip relative">
                  95% PI: [${result.prediction_interval_low.toFixed(
                    1
                  )}% - ${result.prediction_interval_high.toFixed(1)}%]
                  <div class="tooltip">Kernel: ${result.kernel_contribution.toFixed(
                    1
                  )} | ML: ${result.residual_contribution.toFixed(1)}%</div>
              </div>`;
          } catch (error) {
            predictionCell.innerHTML = `<span class="text-red-500 has-tooltip relative">Error<div class="tooltip w-48">${error.message}</div></span>`;
          } finally {
            button.disabled = false;
            button.textContent = 'Predict';
            updateAllVisualizations();
          }
        }

        async function findOptimalMix() {
          findOptimalMixBtn.disabled = true;
          findOptimalMixBtn.textContent = 'Optimizing...';

          const firstRow = tableBody.querySelector('tr');
          if (!firstRow) {
            alert(
              'Please add at least one experiment row to define time and strategy.'
            );
            findOptimalMixBtn.disabled = false;
            findOptimalMixBtn.textContent = 'Find Optimal Mix';
            return;
          }

          // Gather prior experiments with actual results to guide the optimization
          const prior_experiments = Array.from(tableBody.querySelectorAll('tr'))
            .map((row) => {
              const actual = row.querySelector('[data-actual]')?.dataset.actual;
              if (!actual) return null;

              return {
                inputs: {
                  DspB_ratio: parseFloat(
                    row.querySelector('.ratio-dspb').value
                  ),
                  DNase_I_ratio: parseFloat(
                    row.querySelector('.ratio-dnase').value
                  ),
                  ProK_ratio: parseFloat(
                    row.querySelector('.ratio-prok').value
                  ),
                },
                output: parseFloat(actual),
              };
            })
            .filter(Boolean);

          const payload = {
            fixed_conditions: {
              pH: parseFloat(document.getElementById('fixed-ph').value),
              Temperature: parseFloat(
                document.getElementById('fixed-temp').value
              ),
              Total_Volume: parseFloat(
                document.getElementById('total-volume').value
              ),
              biofilm_age_hours: parseFloat(
                document.getElementById('biofilm-age').value
              ),
              Reaction_Time: parseFloat(
                firstRow.querySelector('.total-time').value
              ),
              Addition_Strategy: parseInt(
                firstRow.querySelector('.strategy-select').value
              ),
              DNase_Addition_Time: parseFloat(
                firstRow.querySelector('.dnase-time').value
              ),
              ProK_Addition_Time: parseFloat(
                firstRow.querySelector('.prok-time').value
              ),
            },
            prior_experiments: prior_experiments,
          };

          try {
            const response = await fetch(`${API_URL}/optimize-mix`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });
            const result = await response.json();
            if (!response.ok) {
              throw new Error(result.detail || 'Optimization failed.');
            }

            createRow({
              dspb: result.optimal_DspB_ratio,
              dnase: result.optimal_DNase_I_ratio,
              prok: result.optimal_ProK_ratio,
              strategy: payload.fixed_conditions.Addition_Strategy,
              totalTime: payload.fixed_conditions.Reaction_Time,
              dnaseTime: payload.fixed_conditions.DNase_Addition_Time,
              prokTime: payload.fixed_conditions.ProK_Addition_Time,
            });
          } catch (error) {
            alert(`Error finding optimal mix: ${error.message}`);
          } finally {
            findOptimalMixBtn.disabled = false;
            findOptimalMixBtn.textContent = 'Find Optimal Mix';
          }
        }

        function updateAllVisualizations() {
          updateSummaryMetrics();
          updatePredictionAnalysis();
          renderActualVsPredictedPlot();
          renderTernaryPlot();
        }

        function updateSummaryMetrics() {
          const predictions = Array.from(
            document.querySelectorAll('[data-prediction]')
          ).map((el) => parseFloat(el.dataset.prediction));
          const count = predictions.length;
          document.getElementById('summary-count').textContent = count;
          if (count > 0) {
            document.getElementById('summary-best').textContent = `${Math.max(
              ...predictions
            ).toFixed(1)}%`;
            document.getElementById('summary-mean').textContent = `${(
              predictions.reduce((a, b) => a + b, 0) / count
            ).toFixed(1)}%`;
          } else {
            ['summary-best', 'summary-mean'].forEach(
              (id) => (document.getElementById(id).textContent = '-')
            );
          }
        }

        function updatePredictionAnalysis() {
          let totalError = 0,
            validPairs = 0;
          document.querySelectorAll('#table-body tr').forEach((row) => {
            const actual = row.querySelector('[data-actual]')?.dataset.actual;
            const predicted =
              row.querySelector('[data-prediction]')?.dataset.prediction;
            if (actual && predicted) {
              totalError += Math.abs(
                parseFloat(actual) - parseFloat(predicted)
              );
              validPairs++;
            }
          });
          document.getElementById('analysis-mae').textContent =
            validPairs > 0 ? `${(totalError / validPairs).toFixed(2)}%` : '-';
        }

        async function renderFeatureImportancePlot() {
          try {
            const res = await fetch(`${API_URL}/feature-importance`);
            if (!res.ok) throw new Error('Could not fetch importance data');
            const data = await res.json();
            const features = Object.keys(data);
            const values = Object.values(data);
            const plotData = [
              {
                type: 'bar',
                x: values.slice(0, 10).reverse(),
                y: features.slice(0, 10).reverse(),
                orientation: 'h',
                marker: { color: '#a8c899' },
              },
            ];
            const layout = {
              title: 'Top 10 Feature Importances',
              xaxis: { title: 'Importance Score (MAE reduction)' },
              yaxis: { automargin: true },
            };
            Plotly.newPlot('plot-feature-importance', plotData, layout, {
              responsive: true,
            });
          } catch (error) {
            document.getElementById(
              'plot-feature-importance'
            ).innerHTML = `<div class="text-center text-red-500 p-4">${error.message}</div>`;
          }
        }

        function renderActualVsPredictedPlot() {
          const rows = document.querySelectorAll('#table-body tr');
          const points = Array.from(rows)
            .map((row) => {
              const actual = parseFloat(
                row.querySelector('[data-actual]')?.dataset.actual
              );
              const predicted = parseFloat(
                row.querySelector('[data-prediction]')?.dataset.prediction
              );
              const intervalText = row
                .querySelector('.removal-predicted .has-tooltip')
                ?.textContent.match(/\[(.*?)% - (.*?)%\]/);
              if (isNaN(actual) || isNaN(predicted) || !intervalText)
                return null;
              const [piLow, piHigh] = intervalText.slice(1).map(parseFloat);
              return {
                x: actual,
                y: predicted,
                error_y: {
                  type: 'data',
                  symmetric: false,
                  array: [piHigh - predicted],
                  arrayminus: [predicted - piLow],
                  color: 'rgba(42, 85, 53, 0.3)',
                },
              };
            })
            .filter(Boolean);

          if (points.length === 0) {
            document.getElementById('plot-actual-vs-predicted').innerHTML =
              '<div class="text-center text-gray-400 p-10">Enter actual and predicted values to see plot.</div>';
            return;
          }
          const plotData = [
            {
              x: points.map((d) => d.x),
              y: points.map((d) => d.y),
              error_y: {
                type: 'data',
                symmetric: false,
                array: points.map((p) => p.error_y.array[0]),
                arrayminus: points.map((p) => p.error_y.arrayminus[0]),
                color: 'rgba(42, 85, 53, 0.3)',
              },
              mode: 'markers',
              type: 'scatter',
              name: 'Prediction',
              marker: { color: '#1a472a', size: 8 },
            },
            {
              x: [0, 100],
              y: [0, 100],
              mode: 'lines',
              name: 'Ideal (y=x)',
              line: { dash: 'dash', color: '#ccc' },
            },
          ];
          const layout = {
            title: 'Model Performance',
            xaxis: { title: 'Actual Removal (%)', range: [0, 105] },
            yaxis: { title: 'Predicted Removal (%)', range: [0, 105] },
            showlegend: false,
          };
          Plotly.newPlot('plot-actual-vs-predicted', plotData, layout, {
            responsive: true,
          });
        }

        function renderTernaryPlot() {
          const rows = document.querySelectorAll('#table-body tr');
          const points = Array.from(rows)
            .map((row) => {
              const dspb = parseFloat(row.querySelector('.ratio-dspb')?.value);
              const dnase = parseFloat(
                row.querySelector('.ratio-dnase')?.value
              );
              const prok = parseFloat(row.querySelector('.ratio-prok')?.value);
              const pred = parseFloat(
                row.querySelector('[data-prediction]')?.dataset.prediction
              );
              const total = dspb + dnase + prok;
              if (total === 0 || isNaN(pred)) return null;
              return {
                a: dspb,
                b: dnase,
                c: prok,
                text: `Predicted: ${pred.toFixed(1)}%`,
                color: pred,
              };
            })
            .filter(Boolean);

          if (points.length === 0) {
            document.getElementById('ternary-plot').innerHTML =
              '<div class="text-center text-gray-400 p-10">Run predictions to see enzyme ratios.</div>';
            return;
          }

          const plotData = [
            {
              type: 'scatterternary',
              mode: 'markers',
              a: points.map((d) => d.a),
              b: points.map((d) => d.b),
              c: points.map((d) => d.c),
              text: points.map((d) => d.text),
              marker: {
                size: 9,
                color: points.map((d) => d.color),
                colorscale: 'YlGn',
                colorbar: { title: 'Predicted<br>Removal (%)' },
              },
            },
          ];
          const layout = {
            title: 'Enzyme Ratio vs. Predicted Removal',
            ternary: {
              sum: 100,
              aaxis: { title: 'Dispersin B' },
              baxis: { title: 'DNase I' },
              caxis: { title: 'Proteinase K' },
            },
          };
          Plotly.newPlot('ternary-plot', plotData, layout, {
            responsive: true,
          });
        }

        // --- App Initialization ---
        initialData.forEach((c) =>
          createRow({
            ...c,
            dspb: c.dspb || 0,
            dnase: c.dnase || 0,
            prok: c.prok || 0,
          })
        );
        checkApiStatus();
        updateAllVisualizations();
        addRowBtn.addEventListener('click', () =>
          createRow({
            dspb: 1,
            dnase: 1,
            prok: 1,
            strategy: 0,
            totalTime: 24,
            dnaseTime: 0,
            prokTime: 2,
          })
        );
        findOptimalMixBtn.addEventListener('click', findOptimalMix);
        setInterval(checkApiStatus, 30000);
      });
    </script>
  </body>
</html>
